module MVR
#
# # Let m be a model like

# f(x,y,z) = a*x + b*y + c *z
# x,y,z = rand(Normal(0,1), (n,3))
# target[i] = f(x[i],y[i],z[i]) + rand(Normal(0,1), 1)
# a,b,c = min_{a,b,c} sum_i (f(x[i],y[i],z[i]) - target[i])^2
# So it is a 3variate least squares regression model. Define the set of transformations $T$ as the free monoid generated by

# x^i->x^i+1
# x^i->x^i-1
# y^i->y^i+1
# y^i->y^i-1
# z^i->z^i+1
# z^i->z^i-1
# The free monoid over this set of transformations is actually the product of cyclic groups Z^3 = Z x Z x Z with the group operation of +:Z^3->Z^3. so you get the set of models:

# f(x,y,z) = a*x^i + b*y^j + c *z^k
# x,y,z = rand(Normal(0,1), (n,3))
# target[i] = f(x[i],y[i],z[i]) + rand(Normal(0,1), 1)
# a,b,c = min_{a,b,c} sum_i (f(x[i],y[i],z[i]) - target[i])^2
# for all combinations of integers i,j,k which is a pretty cool structure. If you do the transformations with i mod N then you get Z_N^3 which is a finite abelian group. It doesn't get more computationally tractable than component-wise arithmetic mod N.

# We could then talk about the orbits of a given model under this group. For this group, there is only one orbit, but if you take subgroups like the group generated by (1,1,1) aka<1,1,1> you get multiple orbits. For example if you start with

# f(x,y,z) = a*x^1 + b*y^2 + c *z^3
# x,y,z = rand(Normal(0,1), (n,3))
# target[i] = f(x[i],y[i],z[i]) + rand(Normal(0,1), 1)
# a,b,c = min_{a,b,c} sum_i (f(x[i],y[i],z[i]) - target[i])^2
# the orbit is all of the models of the form

# f(x,y,z) = a*x^1+i + b*y^2+i + c *z^3+i
# x,y,z = rand(Normal(0,1), (n,3))
# target[i] = f(x[i],y[i],z[i]) + rand(Normal(0,1), 1)
# a,b,c = min_{a,b,c} sum_i (f(x[i],y[i],z[i]) - target[i])^2
# where i is in Z mod N. You could reason about finding the best fitting model from a given orbit. and then comparing the orbits to see which one was contained the best fitting model.
# ex = Base.Meta.Parse("module M ... end")
# m = ModelTools.model(ModelTypeA, ex)
# T = ConcatTransform()
# T = AXform(:addvar, :β) ∘ T
# T = AXform(:addrule, :β=>α/2) ∘ T
# m′ = T(m)
# M = eval(Expr(m′))
# sol = M.solve()
expr = quote
    module Regression
    using Random
    using LsqFit
    using LinearAlgebra

    function f(X, β)
        a = β[1]
        b = β[2]
        x = X[:, 1]
        y = X[:, 2]
        return a.*x.^0 .+ b.*y.^0
    end

    function sample(g::Function, n)
        x = randn(Float64, n)
        target = g(x) .+ randn(Float64, n[1])./1600
        return x, target
    end

    function describe(fit)
        if !fit.converged
            error("Did not converge")
        end
        return (β = fit.param, r=norm(fit.resid,2))
    end
    #setup

    # Random.seed!(42)
    β = (1/2, 1/2)
    n = (1000,2)
    g(x) = β[1].*x[:,1].^2 + β[2].*x[:,2].^3
    X, target = sample(g, n)
    # x, y = X[:,1], X[:,2]
    # @show size(X), size(target)
    # loss(a) = sum((f.(a, x, y) .- target).^2)
    # @show loss.([-1,-1/2,-1/4, 0, 1/4,1/3,1/2,2/3, 1])

    a₀ = [1.5, 0.1]
    try
        ŷ₀ = f(X, a₀)
    catch
        error("Could not execute f on the initial data")
    end

    #solving
    fit = curve_fit(f, X, target, a₀; autodiff=:forwarddiff)
    result = describe(fit)
    end
end

include("groups.jl")
using SemanticModels
using SemanticModels.ModelTools
using .Transformations

import SemanticModels.ModelTools: model, AbstractProblem
import SemanticModels.Parsers: findfunc, findassign
import Base: show, one, zero, -, *

one(::Type{Pow}) = Pow(1)
zero(::Type{Pow}) = Pow(0)
-(p::Pow) = Pow(-p.inc)
*(n::Int, p::Transformations.Transformation) = begin
    n >= 0 || error("cannot multiply by negative n")
    n > 0 || return zero(p)
    s = p
    for i in 1:n-1
        s = p∘s
    end
    return s
end

function show(io::IO, p::Pow)
    write(io, "Pow($(p.inc))")
end

function show(io::IO, p::Product)
    write(io, "$(p.dims)")
end

isexpr = Transformations.isexpr

"""    (t::Pow)(m::MultivariateLsq, i::Int)

apply the power transformation to the i-th coordinate of m.

Example:

A program that solves min_β || f(X,β) - y ||_2

`f(X, β) = β[1]*X[:,1]^p + β[2]*X[:,2]^q`
"""
struct MultivariateLsq <: AbstractProblem
    expr
    f
    coefficient
    p₀
end

function show(io::IO, m::MultivariateLsq)
    write(io, "MultivariateLsq(\n  f=$(repr(m.f)),\n  coefficient=$(repr(m.coefficient)),\n  p₀=$(repr(m.p₀))\n)")
end

function model(::Type{MultivariateLsq}, expr::Expr)
    if expr.head == :block
        return model(MultivariateLsq, expr.args[2])
    end
    objective = :l2norm
    f = callsites(expr, :curve_fit)[end].args[3]
    coeff = callsites(expr, f)[1].args[end]
    p₀ = callsites(expr, :curve_fit)[end].args[end]
    return MultivariateLsq(expr, f, coeff, p₀)
end

"""    poly(m::MultivariateLsq)::Expr

find the part of the model that implements the polynomial model for regression.
"""
function poly(m::MultivariateLsq)
    func = findfunc(m.expr, m.f)[1]
    poly = func.args[2].args[end].args[1]
    return poly
end


"""    (t::Pow)(m::MultivariateLsq, i::Int)

apply the power transformation to the i-th coordinate of m.

Example:

If `m` is a program implementing `f(X, β) = β[1]*X[:,1]^p + β[2]*X[:,2]^q`

a) and `t = Pow(2)` then `t(m, 1)` is the model implementing
`f(X, β) = β[1]*X[:,1]^p+2 + β[2]*X[:,2]^q`.

or

b) and `t = Pow(2)` then `t(m, 2)` is the model implementing
`f(X, β) = β[1]*X[:,1]^p + β[2]*X[:,2]^q+2`.

See also [`(t::Pow)(m::MultivariateLsq, i::Int)`](@ref)
"""
function (t::Pow)(m::MultivariateLsq, i::Int)
    p = poly(m)
    comp = p.args[i+1]
    pow = callsites(comp, :(.^))
    pow[end].args[3] += t.inc
    return m
end

"""    (t::Product)(m::MultivariateLsq)

apply the product transformation to the model m.
For a MultivariateLsq model a product transformation works
by applying the transformation component-wise where each component represents a
column of the data.

Example:

If `m` is a program implementing `f(X, β) = β[1]*X[:,1]^p + β[2]*X[:,2]^q`
and `t = Pow(2,-1)` then `t(m)` is the model implementing
`f(X, β) = β[1]*X[:,1]^p+2 + β[2]*X[:,2]^q-1`.
"""
function (t::Product)(m::MultivariateLsq)
    m = m
    for (i, tᵢ) in enumerate(t.dims)
        m = tᵢ(m, i)
    end
    return m
end

m = model(MultivariateLsq, expr)
@show T¹ = Product((one(Pow), zero(Pow)))
@show T² = Product((zero(Pow), one(Pow)))

# @show (2T¹ ∘ 3T²)(m)

# @show (4*one(Pow))(m, 2)

results = []
for i in 1:3
    for j in 1:3
        m₀ = deepcopy(m)
        T = (i*T¹) ∘ (j*T²)
        mᵢⱼ = T(m₀)
        p = poly(mᵢⱼ)
        M = eval(mᵢⱼ.expr)
        push!(results, (i=i, j=j, M.result..., p=p))
    end
end


end

m = MVR.m
results = MVR.results
sort(results, by=x->x.r)
